可视化学习 Go 并发编程

2017.7.27

黄庆兵 - 网易

bingohuang.com

http://talks.bingohuang.com

https://github.com/163yun

* 大纲
- 去年 meetup 分享，提到说，Go 会成为 “21世纪的 C 语言”，面向多核时代
- 几张图，讲讲现在 CPU 的趋势
- 在座的都是 Go 方面的专家
- 让大家以一种新的视角来了解 Go 并发模型和编程

* 什么是并发？
- a way to structure the program
- 一种构造程序的方式
- in a decomposable way
- 以一种可分解的方式
- 专业定义：

* CONCURRENCY IS NOT PARALLELISM - 并发不是并行 - Rob Pike
- concurrency is a design technique
- 并发是一种设计技术
- parallelism is an optimization technique
- 并行是一种优化技术
- Parallelism is simply running things in parallel.
- Concurrent program can run either on single core or multiple cores.
- 视频链接 rob pike
- 最后再来用可视化的方式解答什么是并行，什么是并发？
- 中文容易混淆，但是英文单词就区分的非常明显



* 当今是并发的世界，多核的时代

* 软件不应该是这样子
图-TODO

* 而是这样子
图-TODO

* CONCURRENCY IS HARD
- 并发本身不容易，但是 Go 让并发变的有趣


* GO CONCURRENCY - Go 语言中的并发
- goroutine
- channel
- select{}
: 谢大的每日新闻中，经常提及

* GOROUTINE
- is a lightweight 'process'
- 一个轻量级的线程？
- just prefix func with 'go'
- 只需要在函数前缀加上 `go`
- similar to '&' in UNIX
- 类似于 UNIX 中的 `&`
  go foo()

* CHANNEL
- allows passing messages between goroutines
- 允许在 goroutines 之间传递消息
- similar to pipe in UNIX
- 类似于 UNIX 中的管道
  // send 42 to channel
  ch <- 42
  ...
  // read 42 from channel
  val := <-ch

* SELECT{}
- multiplexing channels I/O
- 多 channles I/O
  select {
      case val := <-ch:
          fmt.Println("Read from channel:", val)
      case ch2 <- 42:
          fmt.Println("Send 42 to channel 2")
  }

* GO CONCURRENCY - 总结一下
- Run new logical 'thread' - 3 characters
- 运行一个新的逻辑线程 - 只需 1 个关键字
- Create pool of goroutines - 3 lines of code
- 创建一个 goroutine 池 - 3行代码
- Safety - automatically
- 保证安全 - 自动的

* CONCURRENT PROGRAMMING HAS NEVER BEEN EASIER
- 并发编程好像从来没有这么容易

* NEW QUESTIONS - 那么问题来了
- How do we teach it?
- 我们怎样去学习它？
- How we build more complex abstractions?
- 我们怎样构建更复杂的抽象概念？
- How we build concurrent pipelines?
- 我们怎样构建并发流水线？
- How do we understand it, after all?
- 最重要的，我们该怎样理解它？

* GOTRACE - 祭出法宝 GOTRACE
- Tool for visualizing Go concurrency using WebGL:
- 一种将 Go 并发过程可视化的开源工具，基于 WebGL
: 该工具非常强大
: 具体的用法，可以看工程，后面也会有简单介绍

* 耳听为虚，眼见为实
: 话不多说，让我们来看一个个实例
# 可运行，可视化

* 一、HELLO, WORLD!
  package main

  func main() {
      ch := make(chan int)

      go func() {
          ch <- 42
      }()

      <-ch
  }

* TIMER
* PING-PONG #2
- 附带一张搞笑的图
* PING-PONG #3
* PING-PONG #36

* CONCURRENT PRIME SIEVE

* MESSAGING PATTERNS
* FAN-IN
* SERVERS
* WORKERS / FAN-OUT / SUBWORKERS
* SERVER+WORKER

* GOMAXPROCS
- go doc runtime GOMAXPROCS
* GOMAXPROCS = 1
* GOMAXPROCS = 24

* GOROUTINES LEAK

* CONCURRENCY VS PARALLELISM
- 可视化并行
- 可视化并发

* GOTRACE
- GO CONCURRENCY TRACER
- It's open-source
- github.com/divan/gotrace
- Uses go execution tracer (go tool trace)
- Requires patched Go (or pre-made docker images) - 最新版好像可以去掉
- (Kind of) language agnostic
- 简单介绍这些是怎么做出来的

* GOTRACE - 早期
- GO CONCURRENCY TRACER
- Uses go execution tracer (go tool trace)
- Rewrites your code and runs it
- Collect the trace
- Analyze and correlate events
- Start web-server serving WebGL visualization
- Requires patched Go (or pre-made docker images)

: 回过头来，我们再介绍一下 divan 大神的这款工具
