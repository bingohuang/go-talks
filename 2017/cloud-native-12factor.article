云原生时代下的12-factor应用与实践

黄庆兵
网易云 • 基础服务
http://c.163.com
http://bingohuang.com

* 简介
在云的时代，应用会更多的迁移到云端，基于云的架构设计和开发模式需要一套全新的理念去承载，于是云原生思想应运而生，而针对云原生应用开发的最佳实践原则，12-Factor脱颖而出，同时也带来了新的解读。本次分享将介绍在Cloud Native时代下，结合Docker等技术，如何一一实践12-Factor原则，并能应用在当代的云平台中。

* 云原生
首先先从我的理解，来简单介绍下云原生这个概念。
所谓云原生（Cloud Native），通常又表达为云原生应用，简单的说就是面向云的应用，这表示我们应该面向云（平台）来设计我们的应用。网易三拾众筹的架构师陈晓辉，还为它起了一个小清新的名字——向云而生，我觉得非常贴切，再通俗一点讲，也可以叫做“云平台应用”，并用下面这幅图一一拆解，可能更直白的理解。

.image cloud-native-12factor/cloud-native.png 300 _

- IaaS看做基础 *云* 设施，用来提供各种基础资源
- PaaS作为开发 *平台*，用来提供各种平台服务
- SaaS交付 *应用* 或服务，直面用户，提供应用价值

可见云原生应用（又叫云平台应用）并非一个空中楼阁，而是构建在一层层服务之上的。

* 12-Factor
12-Factor 全称叫 The Twelve-Factor App，和 Cloud-Native 有异曲同工之处。其中文翻译不少，我觉得“十二要素”或“十二原则”比较贴切，它定义了一个优雅的互联网应用在设计过程中，需要遵循的一些基本原则。
十二要素应用宣言，是由Heroku创始人Adam Wiggins首次提出并开源，并由众多经验丰富的开发者共同完善，这综合了他们关于SaaS应用几乎所有的经验和智慧，是开发此类应用的理想实践标准。

配图：TODO

在接下来的 *应用和实践* 当中，我们会一一实践每条原则。

12-Factor的多语言版本发布在其官网上，为了方便大家阅读和下载，我将其转化了为 GitBook 格式，并架设在网易蜂巢平台，同时开源在 GitHub

- 在线阅读地址：http://12.bingohuang.com
- 原文开源地址：
- pdf/epub下载地址：

* 应用与实践

既然12-factor作为SaaS开发的最佳实践原则，当然脱离不了实践，接下来我们就来设计一款云原生应用，并依照12-factor，一步步验证和升级我们的应用。从中，我们将讲解每个应用的要点，以及对我们应用的意义。最后，你将更深刻的理解12-factor的每条原则。

** 0. 应用准备
基于 Node.js ，开发一个 Web 应用

- 下载安装 Node.js (包含 npm)：https://nodejs.org/zh-cn/download/
- 注：Node 版本只要 4.4 以上就够用，我这里对应用的是：
  node: v5.12.0

基于 Sails，暴露一系列 CRUD 的 HTTP Rest API

- 安装 Sails 框架：npm install sails -g
- 注：Sails 是类似 Rails 框架，用于快速开发 Node.js 应用：http://sailsjs.com/

基于 Docker，作为我们打包、发布、运行的工具

- 安装 Docker：https://docs.docker.com/engine/installation/
- 注：这里不得不说，Docker非常适合 云原生应用和 12-factor 理念

初始化一个项目

  $ sails new 12factor-app
  info: Created a new Sails app `12factor-app`!
  $ cd 12factor-app
  $ sails generate api user
  info: Created a new api!
  $ npm start

本地调试接口

- 浏览器中访问：TODO：部署在蜂巢上，在线试用
  http://localhost:1337
- 本地curl命令：
  $ curl http://localhost:1337/user
  []
  $ curl -XPOST http://localhost:1337/user?name=bingo
  {
    "name": "bingo",
    "createdAt": "2017-02-13T06:13:53.791Z",
    "updatedAt": "2017-02-13T06:13:53.791Z",
    "id": 1
  }
  $ curl http://localhost:1337/user
  [
    {
      "name": "bingo",
      "createdAt": "2017-02-13T06:13:53.791Z",
      "updatedAt": "2017-02-13T06:13:53.791Z",
      "id": 1
    }
  ]
- 在线curl命令：
  curl -XPOST http://59.111.110.95:1337/user?name=bingo

** I. 基准代码
*Factor解说*：

- 一个应用（App），只有一份基准代码（Codebase），可以多份部署（deploy）

意思就是说一个应用只有一份用来跟踪所有修订版本的代码仓库，基准代码和应用之间总是保持一一对应的关系：

- 一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 12-Factor 进行开发。
- 多个应用共享一份基准代码是有悖于 12-Factor 原则的。解决方案是将共享的代码拆分为独立的类库，然后使用 依赖管理（第二个原则） 策略去加载它们。
- 多份 部署 相当于是运行了该应用的多个实例，比如开发环境一个实例，测试环境、生产环境都有一个实例

*Factor实践*：

- 使用Git作为应用的版本管理系统，使用GitHub我们的在线仓库
- 在刚刚创建好的应用目录下执行：

  $ echo "# 12factor-app" >> README.md
  $ git init
  $ git add .
  $ git commit -m "first commit"
  $ git remote add origin git@github.com:bingohuang/12factor-app.git
  $ git push -u origin master

图：TODO

** II. 依赖
*Factor解说*：

- 应用程序必须显式声明依赖关系，即：通过 *依赖清单* 声明所有依赖项，通过 *依赖隔离* 工具确保程序不会调用系统中存在但清单中未声明的依赖项。


- package.json 就是我们的 *依赖清单*，所有应用程序的依赖都声明在此。
  {
  "name": "12factor-app",
  "private": true,
  "version": "0.0.0",
  "description": "a Sails application",
  "keywords": [],
  "dependencies": {
    "ejs": "2.3.4",
    "grunt": "1.0.1",
    "grunt-contrib-clean": "1.0.0",
    "grunt-contrib-coffee": "1.0.0",
    "grunt-contrib-concat": "1.0.1",
    "grunt-contrib-copy": "1.0.0",
    "grunt-contrib-cssmin": "1.0.1",
    "grunt-contrib-jst": "1.0.0",
    "grunt-contrib-less": "1.3.0",
    "grunt-contrib-uglify": "1.0.1",
    "grunt-contrib-watch": "1.0.0",
    "grunt-sails-linker": "~0.10.1",
    "grunt-sync": "0.5.2",
    "include-all": "^1.0.0",
    "rc": "1.0.1",
    "sails": "~0.12.11",
    "sails-disk": "~0.10.9"
  },
  "scripts": {
    "debug": "node debug app.js",
    "start": "node app.js"
  },
  "main": "app.js",
  "repository": {
    "type": "git",
    "url": "git://github.com/bingo/12factor-app.git"
  },
  "author": "bingo",
  "license": ""
  }

 # 接下来我们加入 mongodb 的库依赖（后续会用到），只需要执行：
  npm install sails-mongo --save

 # 同时 package.json 中会有相应的变更
  {
    ...
    "dependencies": {
      ...
      "sails-mongo": "^0.12.2"  //最新加入的依赖
    }
    ...
  }

- node_modules 文件夹就作为 *依赖隔离*，所有应用程序需要用到的库都安装在这里，并且和系统的库是隔离的

** III. 配置
*Factor解说*：

- 推荐将应用的配置存储于 *环境变量* 中，保证配置排除在代码之外
  - 环境变量可以非常方便地在不同的部署间做修改，却不动一行代码
  - 与配置文件不同，不小心把它们签入代码库的概率微乎其微
  - 与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关
  - 存储在环境变量中的另一个好处是，方便和Docker配合使用

- 判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用可以立刻开源，而不用担心会暴露任何敏感的信息：）

*Factor实践*：

- 在应用程序的 _config/connections.js_ 文件中，我们使用 MONGO_URL 这个环境变量来定义 _mongo_ 的连接方式
  module.exports.connections = {
    mongo: {
       adapter: 'sails-mongo',
       url: process.env.MONGO_URL
    }
  };
- 在 文件中，指定module所使用的连接
  module.exports.models = {
    connection: mongo,
    migrate: 'safe'
  };
- 如果你在本地起了一个mongodb测试服务，就可以用这个命令验证应用是否正常配置
  MONGO_URL=mongodb://localhost:27017/12factor-app npm start

** IV. 后端服务
*Factor解说*：

- 把后端服务(backing services)当作附加资源
- 后端服务是指程序运行所需要的通过网络调用的各种服务，如数据库（MySQL），消息/队列系统（RabbitMQ），SMTP 邮件发送服务（ Postfix），以及缓存系统（Memcached）等
- 除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务，如 SMTP（例如 Postmark），数据收集服务，数据存储服务（如 Amazon S3），以及使用 API 访问的服务（例如 Twitter）等
- 12-Factor 应用不会区别对待本地或第三方服务。
- 对应用程序而言，两种都是附加资源，通过一个 url 或是其他存储在 配置 中的设置来获取数据，仅需修改配置中的资源地址即可。

图：TODO

详情: http://localhost:4000/zh_cn/backing-services.html

*Factor实践*：

- 对我们的应用程序来说，用到的后端服务就是 MongoDB 数据库。我们正是通过 MONGO_URL 来传递 MongoDB 的资源地址，从而实现了后端服务和应用程序的解耦。
- 如果当前这个 MongoDB 实例出问题了，我们可以通过设置 MONGO_URL 这个环境变量，很方便的切换一个新的实例

** V. 构建，发布，运行
*Factor解说*：

- 12-facfor 应用严格区分构建，发布，运行这三个步骤
- Docker 的 Build, Ship and Run 理念就很好的契合了这条原则
- 发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本
- 直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤

图：

*Factor实践*：

我们将隆重推出 Docker及其组件，它将适合在整个构建、发布和运行流程，我们也将从这三个方面进行讲解。

构建：

- 书写构建脚本：Dockerfile
  FROM hub.c.163.com/library/node:5.12.0
  MAINTAINER bingohuang <me@bingohuang.com>
  # 拷贝依赖清单
  COPY package.json /tmp/package.json
  # 安装依赖包
  RUN cd /tmp && npm install --registry=https://registry.npm.taobao.org
  # 将依赖包拷贝到应用程序目录下
  RUN mkdir /app && cp -a /tmp/node_modules /app/
  # 更改工作目录
  WORKDIR /app
  # 拷贝应用程序代码
  COPY . /app
  # 设置应用启动端口
  ENV PORT 1337
  # 暴露应用程序端口
  EXPOSE 1337
  # 启动应用
  CMD ["npm","start"]
- Docker 构建
  $ docker build -t message-app:v1.0 .
- Docker 推送：可以将其 push 到指定的镜像仓库，比如网易蜂巢的镜像仓库
  docker push hub.c.163.com/bingohuang/12factor-app:1.0

发布：

- 书写发布脚本：docker-compose.yml
  version: '2'
  services:
  mongo:
    image: hub.c.163.com/library/mongo:3.2
    volumes:
      - mongo-data:/data/db
    ports:
      - "27017:27017"
  app:
    image: hub.c.163.com/bingohuang/12factor-app:1.0
    ports:
      - "1337:1337"
    links:
      - mongo
    depends_on:
      - mongo
    environment:
      - MONGO_URL=mongodb://mongo/12factor-app
  volumes:
    mongo-data:
- 以上在已有构建的基础上，定义了一个发布过程，并将配置（MONGO_URL）通过环境变量注入进去
  MONGO_URL=mongodb://mongo/12factor-app

运行：

- 可以通过Docker Compose在本地运行，也可以通过云平台来在线编排（网易蜂巢即将支持服务编排功能）
  docker-compose up -d
- 继而查看日志
  docker-compose logs -f

注：为了方便不熟悉docker和docker-compose命令的人快速运行程序和本地调试，我在源代码中还提供了 docker.sh 脚本，方便构建、发布和运行应用。

** VI. 进程
*Factor解说*：

- 运行环境中，应用程序通常是以一个和多个 进程 运行的。
  最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行（例如python my_script.py）。另外一个极端情况是，复杂的应用可能会使用很多 进程类型 ，也就是零个或多个进程实例。
- 12-Factor 应用的进程必须无状态且无共享。
  任何需要持久化的数据都要存储在 后端服务 内，比如数据库。
  Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。
- 这么做是为了：
  - 可扩展性
  - 错误容忍

*Factor实践*：
- 虽然这是一个简单的demo应用，但查看docker容器中的运行进程，发现也有4个进程在运行，其中 `npm` 也就是我们的启动进程
  $ docker  exec eaaa922abf08 ps aux
  USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
  root         1  0.2  2.0 1076204 42024 ?       Ssl  18:22   0:00 npm
  root        17  0.0  0.0   4340   724 ?        S    18:22   0:00 sh -c node app.js
  root        18  0.9  4.5 1253808 93808 ?       Sl   18:22   0:01 node app.js
  root        27  1.1  3.7 962884 77076 ?        Sl   18:22   0:01 grunt
- 我们 的应用进程是无状态的，持久化的数据都存储在了后端服务 MongoDB 当中

.image cloud-native-12factor/6-factor-app-done.jpg 300 _

** VII. 端口绑定
*Factor解说*：

- 12-Factor 应用通过自我加载而不依赖于任何网络服务器就可以创建一个面向网络的服务。
- 互联网应用通过端口绑定(Port binding)来提供服务 ，并监听发送至该端口的请求。
- 还要指出的是，端口绑定这种方式也意味着一个应用可以成为另外一个应用的 后端服务 ，调用方将服务方提供的相应 URL 当作资源存入 配置 以备将来调用。

*Factor实践*：

- docker-compose文件为我们很好的定义了端口绑定
  ports:
      - "1337:1337" // 应用容器暴露1337端口在容器中，宿主机将其映射到1337端口
- 需要注意的是，如果在一个宿主机中部署多个应用实例，就不能将一个宿主机端口映射到多个容器端口（端口冲突），解决方法是在这之上加一个负载均衡，负载宿主机的不同端口服务所对应的不同容器。

** VIII. 并发
*Factor解说*：

- 在 12-factor 应用中，进程是一等公民。
- 12-Factor 应用的进程所具备的无共享，水平分区的特性
- 上述进程模型会在系统急需扩展时大放异彩，意味着添加并发会变得简单而稳妥
- 举例来说，HTTP 请求可以交给 web 进程来处理，而常驻的后台工作则交由 worker 进程负责，定时任务交由 clock 来处理，如下图：
.image cloud-native-12factor/process-types.png 400 _

*Factor实践*：

- 如第六个要素所描述，我们的应用拥有多个进程，最主要的是 Node.js 的http server进程，进程都是无状态并无共享，所以可以非常容易的做水平扩展。

** IX. 易处理
*Factor解说*：

- 12-Factor 应用的 进程 是 易处理（disposable）的，意思是说它们可以快速启动和优雅终止
- 这有利于快速、弹性的伸缩应用，迅速部署变化的代码或配置，提高健壮性
- 进程应当追求最小启动时间，可以提供了更敏捷的发布以及扩展过程
- 进程一旦接收终止信号（SIGTERM） 就会优雅的终止
- 在云平台的基础上，可以做到更好的易处理

图：TODO

*Factor实践*：

- Docker 的轻量级，就非常适合来做快速启动和优雅终止，非常适合该实践原则
- 应用是无状态的，在其之上，再架设一个负载均衡，可以使应用的升级不对用户产品影响
- 构建在网易蜂巢容器云平台之上，可以优雅的处理进程的启动和停止。

** X. 环境等价
*Factor解说*：

- 尽可能的保持开发，预发布，线上环境相同
- 12-Factor 应用想要做到持续部署就必须缩小本地与线上差异，包括以下三种差异：
  缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码
  缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现
  缩小工具差异：尽量保证开发环境以及线上环境的一致性
- 12-Factor 应用的开发人员应该反对在不同环境间使用不同的后端服务
  这是因为，不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。

*Factor实践*：

- 我们的应用程序中，使用了docker-compose作为我们的发布脚本，它使得应用既可以在本地运行，也可以在任何支持 Docker 的云平台上运行，应用无需变化，只需修改配置文件，很好的解除了不同环境的差异化
- 从以往经验来看，传统应用和12-Factor应用会存在如下差异：

.image cloud-native-12factor/env-parity.png 200 _


** XI. 日志
*Factor解说*：

- 日志使得应用程序运行的动作变得透明。
- 日志应该是事件流的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。
- 12-factor应用本身从不考虑存储自己的输出流。相反，每一个运行的进程都会直接的标准输出（stdout）事件流。
  开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动
  在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。

*Factor实践*：

- 许多服务都能提供日志集中管理，比如ELK、Splunk、Logentries，而且大多数都能方便的和Docker集成在一起
- 这里以 Logentries 为例来为应用集成日志服务，需要在 docker-compose 文件中加入 log 服务，如下：
  log:
    command: '-t a80277ea-4233-7785203ae328'
    image: 'logentries/docker-logentries’
    restart: always
    tags:
      - development
    volumes:
      - '/var/run/docker.sock:/var/run/docker.sock'
- 一个典型的 Logentries 面板界面如下：

.image cloud-native-12factor/logentries.png 300 _

** XII. 管理进程
*Factor解说*：

- 开发人员经常希望执行一些管理或维护应用的一次性任务，例如：
  - 运行数据移植
  - 运行一个控制台也被称为 REPL shell），来执行一些代码或是针对线上数据库做一些检查。
  - 运行一些提交到代码仓库的一次性脚本。
- 一次性管理进程应该和正常的常驻进程（应用进程）使用同样的环境，并且使用相同的代码和配置，基于某个发布版本运行，随着其他的应用程序一起发布

*Factor实践*：

- 我们可以在 docker-compose 文件中定义管理服务，和程序一起执行
- 我们可以通过通过docker exec命令执行一些管理任务，比如：
  docker exec -ti ADMIN_CONTAINER_ID bash
- 如果多个容器处在相同的网络下，可以通过一个容器来管理其它容器

* 总结
至此，12-Factor一一实践完毕，从中可以看出，12-Factor并非相互独立，而是一个整体，有的涉及代码和框架（Node和Rails），有的涉及工具（Docker和Compose）有的涉及架构和平台。在云原生时代，12-Factor仍然具有强大的生命力，每一条原则都是应用开发的珠玑，而且每一个原则也不是一成不变的，随着新的理念出现，原有的Factor会得到延伸和发展，也会出现新的原则，有兴趣的同学，不妨读一读《Beyond the 12  Factor App》这本书，还会有更大的收获。最后，希望此次分享对你理解云原生应用、实践12-Factor有所帮助。
